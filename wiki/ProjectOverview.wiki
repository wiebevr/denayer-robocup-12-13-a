||<wiki:toc max_depth="2" />||

= Introduction =

For our course in Smart Embedded Systems at Lessius Mechelen Campus De Nayer, we have to create a Robocup SSL-project. The goal of this project is to create an autonomous robot, that can play a simplified version of soccer.

= Architecture =

The total architecture of this project is divided into 4 subsystems. First, the Image Processing-unit will process the images received by the camera. Then, the Wifi-unit will send the information from the local computer to the robot over Wifi. Afterwards, the Strategy-unit provides a strategy on what the robot should do. And finally, the Low Level Communication-unit will control the wheels of the robot. Every unit is explained more detailed underneath.

= Modules =
== Image Processing (IP-unit) ==

A camera positioned above the field provides images to the central computer at a framerate of 4fps. These images are processed by the IP-unit. You can find an example of an image underneath.

<img src="http://denayer-robocup-12-13-a.googlecode.com/svn/wiki/images/afbeelding.jpg" alt="Pulpit rock" width="500" height="360" float="center">

Out of these images, the coördinates of each object on the field will be calculated. With the field being green, the ball being orange, and a pattern present on the robot, the most logical technique to use, is Color Segmentation.

Now that the coördinates are known, they have to be send to the robot. The coördinates are delivered to the WIFI-unit.


Example of a reference^(1)^

The information received from the IP-unit has to be send to the robot. The Wifi unit collects the data and assembles it into 1 object. Via protocol buffers the data is transmitted over the WIFI-network. The protocol used for this transmission is UDP. There will be know acknowledgement from the robot that he's received the package. If he were to miss one package, the next one will arrive shortly without too much data-loss.

== Strategy ==

The robot needs to interpret the coordinates received over WIFI. The strategy determines whether the robot has to kick the ball, or keep the ball out of the goal. For example: in which direction does the robot need to turn, move or kick. These instructions are given to the low level communication-unit.

== Low-level Communication ==
       
The Low-level Communication-unit receives instruction from the strategy-unit. Based on these instructions and their parameters the robot has to drive forward or turn around until a stop-instruction is received. For this to happen, the engines of the robot have to be controlled.

= Technologies and Frameworks =
== CMake:Out of source build (compileren met cmake) ==
=== De `CMakeLists.txt` file ===
Het deel van het project dat draait op de robot wordt gecompileerd met
cmake. In elke directory van de modules staat een `CMakeLists.txt` file. In deze file worden de bestanden die gebruikt worden in het project op de volgende manier toegevoegd (voorbeeld van strategy) :
{{{
cmake_minimum_required (VERSION 2.8)

include_directories("${ROBOT_SOURCE_DIR}")

link_directories("${ROBOT_BINARY_DIR}/lib")

set(strategy_source_files
	main.cpp	
	kicker.cpp
	kicker.h
	robot.cpp
	robot.h
)

add_executable(strategy ${strategy_source_files})

target_link_libraries(strategy ipc)
}}}
Het volstaat dus een variabele aan te maken `${strategy_source_files}` die een lijst van souce files bevat (Neem hier voor iedere module een andere naam!).

Deze variabele wordt dan meegegeven met add_executable.

=== Het project builden ===
Het bouwen van het project gebeurd bij voorkeur "out of source", dit betekent dat alle gegenereerde files (wat er bij cmake redelijk veel zijn) buiten de broncode-map worden gebuild. Dit zorgt ervoor dat de broncode boom mooi blijft en er geen clutter op de svn repo's komt.

In de map robot is op svn als een map `build` aangemaakt. Svn is in deze map zo geconfigureerd dat alle files hierin genegeerd worden. Om te builden ga je eerst in een terminal naar de build map:
{{{
cd robot/build
}}}
In de build map type je:
{{{
cmake ..
}}}
De `..` verwijst naar de root directory van de broncode, de `CMakeLists.txt` file in deze map wordt ingelezen. Het cmake commando genereert een makefile. Na cmake moet enkel nog het make-commando uitgevoerd worden om het project te compilen. 

Als het compileren zonder error's is verlopen worden alle gegenereerde executables in de map `robot/build/bin` gezet.

*Zorg er steeds voor dat code die gecommit wordt naar de repo's
compileerd zodat andere groepen deze code zonder problemen kunnen binnen halen en compileren.*

==== Cross compileren ====
Het maken van een executable dat draait op het beagle board gebeurt als volgt:
 * Ga naar de map `Source/robot/env/` in deze map staat een script `set_me_up.sh`, dit script zal de omgeving (libraries, cross compiler ..) downloaden en uitpakken in de map env.
 * Hierna moet cmake als volgt uitgevoerd worden:
   * In de map build:
{{{
cmake -DCMAKE_TOOLCHAIN_FILE=../toolchain-bb.cmake ..
}}}
  Dit laad de toolchain file toolchain-bb.cmake waarin alle opties voor cmake en de compiler staan ingesteld.
 * Daarna moet enkel nog `make` uitgevoerd worden en de arm executables staan klaar in het build/bin folder.

= References =
List of references

 ^(1)^ Ref 1<br/>
 ^(2)^ Ref 2<br/>
 ^(3)^ Ref 3<br/>